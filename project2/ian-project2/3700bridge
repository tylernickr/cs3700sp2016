#!/usr/bin/python -u    
# The -u makes output unbuffered, so it will show up immediately
import sys
import socket
import select
import json
import time

class Bridge:
    
    def __init__(self, id, lans):
        self.id = id
        
        self.setupPortFields()
        self.setupBpduFields()

        ## forwarding table
        self.forwardingTable = {}
        self.selfLoopPorts = []

        print("Bridge " + self.id + " starting up")
        self.pluginPorts(lans)
        self.broadcastBpdu()

    def setupPortFields(self):
        print("SETUP PORT FIELDS")
        self.disabledPorts = []
        self.disabledPortsForNextHop = []
        self.rootPort = None
        self.rootSource = None
        self.bridgeMap = {}
        self.designatedPorts = []
    
    def setupBpduFields(self):
        self.bpdu = {
            "cost": 0,
            "root": self.id,
            "nextHop": self.id
        }
        self.lastSentBpduTime = 0
        self.lastReceivedFromNextHop = 0
    
    def pluginPorts(self, lans):
        ## create a socket for every LAN and connect
        self.ports = []
        self.portMap = {}
        portIndex = 0
        for lan in lans:
            s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            s.connect(self.padLan(lan))
            self.ports.append(s)
            self.portMap[s] = str(portIndex) + "(" + lan + ")"
            portIndex += 1

    ## pads the name with null bytes at the end
    def padLan(self, name):
        result = '\0' + name
        while len(result) < 108:
            result += '\0'
        return result

    ## broadcast a BPDU to everyone
    def broadcastBpdu(self):
        self.lastSentBpduTime = time.time()
        for port in self.ports:
            bpdu = self.constructBpdu(port)
            port.send(bpdu)
    
    def constructBpdu(self, port):
        bpdu = self.bpdu
        bpdu['port'] = self.portMap[port]
        bpdu['timeSent'] = self.lastSentBpduTime
        message = json.dumps({ "source": self.id, "dest": "ffff", "type": "bpdu", "message": json.dumps(bpdu) })
        return message

    ########### LOG OUTPUT FUNCTIONS #############
    def printNewRoot(self, root):
        print("New Root: " + self.id + "/" + root)
    
    def printNewCost(self, cost):
        print("New Cost: " + self.id + "/" + str(cost + 1))
    
    def printNewPort(self, port):
        print("Root Port: " + self.id + "/" + port)
    
    def printDisabledPort(self, port):
        print("Disabled Port: " + self.id + "/" + port)
    
    def printDesignatedPort(self, port):
        print("Designated Port: " + self.id + "/" + port)
    
    def printBroadcastMessage(self, msg):
        print("Broadcasting message " + msg + " to all ports")
    
    def printForwardedMessage(self, msg, dest):
        print("Forwarding message " + msg + " to port " + dest)
    
    def printDroppedMessage(self, msg):
        print("Not forwarding message " + msg)

    def printReceivedMessage(self, msg, port, source, dest):
        print("Received message " + msg + " on port " + port + " from " + source + " to " + dest)

    def printForwardingTable(self):
        for source, (who, timeReceived) in self.forwardingTable.iteritems():
            print("FORWARDING TABLE ENTRY: " + self.id + "/" + source + ":" + self.portMap[who])

    ########### UPDATE FUNCTIONS    #############
    def designatePort(self, port):
        self.enablePort(port)
        if self.notDisabledForNextHop(port):
            if self.designatedPorts.count(port) == 0:
                self.printDesignatedPort(self.portMap[port])
                self.designatedPorts.append(port)
                self.flushForwardingTable()

    def enablePort(self, port):
        if not self.notDisabled(port) and self.notDisabledForNextHop(port):
            print("Enabled Port: " + self.id + "/" + self.portMap[port])
            self.disabledPorts.remove(port)
    
    def disablePort(self, port):
        if self.notDisabled(port):
            self.printDisabledPort(self.portMap[port])
            self.disabledPorts.append(port)
            self.flushForwardingTable()

    def disablePortForNextHop(self, port):
        self.disablePort(port)
        if self.disabledPortsForNextHop.count(port) == 0:
            self.disabledPortsForNextHop.append(port)

    def foundNewRoot(self, root, cost, source, port, timeNow):
        self.printNewRoot(root)
        self.bpdu['root'] = root
        self.foundNewCost(cost, source, port, timeNow)
    
    def foundNewCost(self, cost, source, port, timeNow):
        self.printNewCost(cost)
        self.bpdu['cost'] = cost + 1
        self.foundNewHop(source, port, timeNow)
    
    def foundNewHop(self, source, port, timeNow):
        self.printNewPort(self.portMap[port])
        self.bpdu['nextHop'] = source
        self.rootPort = port
        self.enablePort(port)
        self.flushForwardingTable()
        self.clearDisabledPortsForNextHop()
        self.lastReceivedFromNextHop = timeNow
        self.broadcastBpdu()
    
    def updateForwardingTable(self, source, who, timeReceived):
        oldWho, oldTime = self.forwardingTable.get(source, (None, None))
        if oldTime is not None and self.portMap[who] != self.portMap[oldWho]:
            pass
        else:
            self.forwardingTable[source] = (who, timeReceived)
    
    def flushForwardingTable(self):
        self.forwardingTable = {}  
   
    def cleanForwardingTable(self, timeNow):
        oldTable = self.forwardingTable
        self.flushForwardingTable()
        for source, (who, timeReceived) in oldTable.iteritems():
            if timeNow - timeReceived <= 5.000: # entry has not timed out
                self.updateForwardingTable(source, who, timeReceived)

    def clearDisabledPortsForNextHop(self):
        self.disabledPortsForNextHop = []

    ########### PORT STATUS FUNCTIONS ############
    def notDisabledForNextHop(self, port):
        for disabled in self.disabledPortsForNextHop:
            if self.portMap[port] == self.portMap[disabled]:
                return False
        return True
    def notDisabled(self, port):
        for disabled in self.disabledPorts:
            if self.portMap[port] == self.portMap[disabled]:
                return False
        return self.notSelfLoop(self.portMap[port])
    
    def notSelfLoop(self, port):
        for loop in self.selfLoopPorts:
            if loop == port:
                return False
        return True

    def detectBridgeFailure(self, timeNow):
        for bridge, lastTime in self.bridgeMap.iteritems():
            if timeNow - lastTime > 0.750: # bridge is dead.
                return True
        return False

    ########### HANDLE DATA MESSAGES #############
    def handleData(self, dataObj, portInc):
        source, dest, message = dataObj['source'], dataObj['dest'], dataObj['message']
        msgId = str(message['id'])
        if not self.notDisabled(portInc):
            return
        print("bridge " + self.id + " handling data from port " + self.portMap[portInc]) 
        #self.printForwardingTable()
        mappedPort = self.portMap[portInc]
        self.updateForwardingTable(source, portInc, time.time())
        msgString = json.dumps(dataObj)
        self.printReceivedMessage(msgId, mappedPort, source, dest)
        if dest == "ffff":
            self.printBroadcastMessage(msgId)
            for portOut in self.ports:
                if mappedPort != self.portMap[portOut] and self.notDisabled(portOut):
                    portOut.send(msgString)
        else:
            forwardingPort, when = self.forwardingTable.get(dest, (None, None))
            if forwardingPort is None:
                self.printBroadcastMessage(msgId)
                for portOut in self.ports:
                    if mappedPort != self.portMap[portOut] and self.notDisabled(portOut):
                        portOut.send(msgString)
            elif mappedPort != self.portMap[forwardingPort]:
                self.printForwardedMessage(msgId,self.portMap[forwardingPort])
                forwardingPort.send(msgString)
            else: # we don't need to forward message back to its sender
                self.printDroppedMessage(msgId)
    
    ########### HANDLE BPDU MESSAGES #############
    def handleBpdu(self, dataObj, port, timeNow):
        bpdu = json.loads(dataObj['message'])
        root, cost, nextHop, timeSent = bpdu['root'], bpdu['cost'], bpdu['nextHop'], bpdu['timeSent']
        source = dataObj['source']
        print("CURRENT BPDU: " + self.id + "/" + str(self.bpdu))
        print("INCOMING: " + (str(dataObj)) + " on port " + self.portMap[port])
        self.bridgeMap[source] = timeNow
        if source == self.id: ## we just received a BPDU from ourselves.  Self-loop!
            toDisable = bpdu['port']
            if self.notSelfLoop(toDisable): ## not already noted as a self loop
                self.selfLoopPorts.append(toDisable)
                self.printDisabledPort(toDisable)
        elif self.bpdu['root'] > root: ## their root is lower, use their BPDU
            self.foundNewRoot(root, cost, source, port, timeNow)
        elif self.bpdu['root'] < root: ## our root is lower, ignore their BPDU
            pass
        ## ROOTS ARE EQUIVALENT
        elif self.bpdu['cost'] > cost + 1: ## our cost is larger than going through them, use their BPDU
            self.foundNewCost(cost, source, port, timeNow)
        elif self.bpdu['cost'] < cost: ## their cost is larger than ours
            if self.id == nextHop: ## they go through us, designate the port
                self.designatePort(port)
                #self.printDesignatedPort(self.portMap[port])
                #self.enablePort(port)
                #self.flushForwardingTable()
            else: ## they don't go through us
                pass
        elif self.bpdu['cost'] == cost: ## our costs are exactly equal
            if self.portMap[port] == self.portMap[self.rootPort]: # NEVER disable root port without setting a new one
                pass
            elif self.bpdu['nextHop'] == nextHop: # their next hop is our next hop
                if self.id > source: # our ID is bigger
                    self.disablePort(port)
                else:
                    self.designatePort(port)
                    #self.printDesignatedPort(self.portMap[port])
                    #self.enablePort(port)
                    #self.flushForwardingTable()
            else: # their hop isn't our next hop.  disable the port since this isn't root traffic
                self.disablePort(port)

        ## SELF COST = INCOMING COST + 1
        elif self.bpdu['nextHop'] > source: ## our next hop is larger than them, use their BPDU
            self.foundNewHop(source, port, timeNow)
        elif self.bpdu['nextHop'] < source: ## our hop is smaller than them, disable port
            if self.portMap[port] != self.portMap[self.rootPort]:
                self.disablePort(port)
        else: ## they are our next hop
            self.lastReceivedFromNextHop = timeNow
            if self.portMap[port] == self.portMap[self.rootPort]: ## we got a BPDU from our next hop
                pass # nothing to do
            else: ## disable to prevent a loop
                ## this port needs to stay disabled until we pick a new next hop
                self.disablePortForNextHop(port)

    ## main method
    def main(self):
        while True:
            receivers, senders, exceptional = select.select(self.ports, [], [], 0.1)
            timeNow = time.time()
            for port in receivers:
                if self.notSelfLoop(self.portMap[port]):
                    data = port.recv(1500)
                    dataObj = json.loads(data)
                    if dataObj['type'] == "bpdu":
                        self.handleBpdu(dataObj, port, timeNow)
                    elif dataObj['type'] == "data":
                        self.handleData(dataObj, port)
                    else:
                        pass # print("encountered bad message of type " + dataObj['type'])
            self.cleanForwardingTable(timeNow)
            if self.detectBridgeFailure(timeNow):
                self.resetBridge()
            if timeNow - self.lastSentBpduTime > 0.500:
                self.broadcastBpdu()
    
    def resetBridge(self):
        print("RESET BRIDGE")
        self.setupPortFields()
        self.setupBpduFields()
        self.flushForwardingTable()
        self.broadcastBpdu()

if __name__ == "__main__":
    id = sys.argv[1]
    lans = sys.argv[2:]
    print("main run with id " + id + " and lans " + str(lans))
    bridge = Bridge(id, lans)
    bridge.main()
