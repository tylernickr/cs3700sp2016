#!/usr/bin/env python

import sys, socket, select, time, json, random, math

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

last = 0

class KVStore:
    
    def __init__(self, id):
        self.id = id
        self.db = {}
        self.leader = 'FFFF'
        
        self.term = 0
        self.commits = 0
        
        time.sleep(.5)
        self.last_heartbeat = time.time()
        self.leader_timeout = .3
        
        self.num_replicas = len(replica_ids) + 1
        
        self.state = 'follower'
        
        self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        self.sock.connect(self.id)
        
    def forward_put_to_leader(self, msg):
        to_send = {'src': self.id, 'dst': self.leader, 'MID': msg['MID'],  'type': 'put', 'leader': self.leader, 'key': msg['key'], 'value': msg['value']}
        self.sock.send(json.dumps(to_send))
        
    def forward_put_and_wait_for_response(self, msg):
        last_send = time.time()
        first_send = time.time()
        self.forward_put_to_leader(msg)
        while time.time() - first_send < .5:
            if time.time() - last_send > .35:
                self.forward_put_to_leader(msg)
            
            ready = select.select([self.sock], [], [], 0.1)[0]
            if self.sock in ready:
                msg_raw = self.sock.recv(32768)
                if len(msg_raw) == 0:
                    continue
                
                response = json.loads(msg_raw)
                #print self.id + " read something: " + response['type']
                
                if response['type'] in ['put', 'get']:
                    #got the wrong thing
                    self.send_failed_response(response)
                elif response['type'] == 'ok':
                    return True
        
        return False
                    
    def send_put_to_replicas(self, msg):
        to_send = {'src': self.id, 'dst': 'FFFF', 'type': msg['type'], 'leader': self.id, 'key': msg['key'], 'value': msg['value'], 'MID': msg['MID']}
        self.sock.send(json.dumps(to_send))
        
    def send_put_response(self, msg):
        to_send = {'src': self.id, 'dst': msg['src'], 'leader': self.leader, 'type': 'ok', 'MID': msg['MID']}
        self.sock.send(json.dumps(to_send))
        #print self.id + ": finished sending response to: " + to_send['dst']
        
    def send_get_response(self, msg, value):
        to_send = {'src': self.id, 'dst': msg['src'], 'leader': self.leader, 'type': 'ok', 'MID': msg['MID'], 'value':value}
        self.sock.send(json.dumps(to_send))
        
    def send_failed_response(self, msg):
        to_send = {'src': self.id, 'dst': msg['src'], 'leader': self.leader, 'type': 'fail', 'MID': msg['MID']}
        
    def send_RPC(self):
        msg = {'src': self.id, 'dst': 'FFFF', 'leader': self.leader, 'type': 'rpc', 'term': self.term}
        self.sock.send(json.dumps(msg))
        
    def send_vote(self, dest):
        msg = {'src': self.id, 'dst': dest, 'leader': dest, 'type': 'vote'}
        self.sock.send(json.dumps(msg))
        
    def begin_election(self):
        self.leader_timeout = 2
        print self.id + ": is trying to be leader"
        self.leader = 'FFFF'
        self.state = 'candidate'
        self.term += 1
        votes = [self.id]
        election_start = time.time()
        election_timeout = (random.random() * .4) + .3
        while len(votes) < math.ceil(self.num_replicas / 2):
            self.send_RPC()
            
            if time.time() - election_start > election_timeout:
                #timed out, abort election
                self.state = 'follower'
                return
                
            ready = select.select([self.sock], [], [], 0.1)[0]
            if self.sock in ready:
                msg_raw = self.sock.recv(32768)
                
                if len(msg_raw) == 0:
                    continue
                    
                msg = json.loads(msg_raw)
                
                if msg['type'] in ['get', 'put']:
                    self.send_failed_response(msg)
                    
                elif msg['type'] == 'rpc':
                    #only one case to worry about
                    if msg['leader'] == msg['src']:
                        #this person has won an election
                        if msg['term'] >= self.term:
                            #They're legit, go with them
                            self.leader = msg['src']
                            self.state = 'follower'
                            return
                            
                elif msg['type'] == 'vote':
                    if msg['src'] not in votes:
                        votes.append(msg['src'])
                        
        #after winning the election
        self.leader = self.id
        self.state = 'leader'
        self.send_RPC()
        print self.id + " JUST WON THE ELECTION"
        
    def vote_in_election(self, candidate_id):
        self.leader_timeout = 2
        self.leader = 'FFFF'
        self.term += 1
        self.send_vote(candidate_id)
        last_voted = time.time()
        while True:
            if time.time() - last_voted > .25:
                self.send_vote(candidate_id)
        
            ready = select.select([self.sock], [], [], 0.1)[0]
            if self.sock in ready:
                msg_raw = self.sock.recv(32768)
                
                if len(msg_raw) == 0:
                    continue
                    
                msg = json.loads(msg_raw)
                
                if msg['type'] in ['get', 'put']:
                    self.send_failed_response(msg)
                    
                elif msg['type'] == 'rpc':
                
                    if msg['leader'] == msg['src']:
                        #someone won
                        break
                    elif msg['term'] > self.term:
                        #apparently a new election started
                        self.vote_in_election(msg['src'])
                        return
                    else:
                        continue
                        
        
        #after the election is over
        self.leader = msg['leader']
        
        
    def time_to_elect_new_leader(self):
        return time.time() - self.last_heartbeat > self.leader_timeout and not self.id == self.leader
    
    def get(self, key):
        if key in self.db:
            #print self.id + ": got (" + key + ", " + self.db[key] + ")"
            return self.db[key]
        else:
            return ""
        
    def put(self, key, value):
        self.db[key] = value
        self.commits += 1
        #print self.id + ": put (" + key + ", " + value + ")"
        
    def is_leader(self):
        return self.id == self.leader
        

kvstore = KVStore(my_id)
time.sleep(.5)
kvstore.last_heartbeat = time.time()
while True:
    if kvstore.time_to_elect_new_leader():
        print "starting election"
        kvstore.begin_election()
        continue
        
    ready = select.select([kvstore.sock], [], [], 0.1)[0]
    
    if kvstore.sock in ready:
        msg_raw = kvstore.sock.recv(32768)
        
        if len(msg_raw) == 0: 
            continue
            
        msg = json.loads(msg_raw)
        
        # For now, ignore get() and put() from clients
        if msg['type'] == 'get':
            value = kvstore.get(msg['key'])
            kvstore.send_get_response(msg, value)
        
        elif msg['type'] == 'put':
            if msg['src'] == kvstore.id:
                pass
                
            if kvstore.is_leader():
                kvstore.put(msg['key'], msg['value'])
                #print "leader put msg: " + msg['MID'] + " sent from: " + msg['src']
                kvstore.send_put_to_replicas(msg)
                kvstore.send_put_response(msg)
            elif msg['src'] == kvstore.leader:
                kvstore.put(msg['key'], msg['value'])
                kvstore.last_heartbeat = time.time()
            else:
                print kvstore.id + ": forwarding and waiting: " + msg['MID']
                result = kvstore.forward_put_and_wait_for_response(msg)
                if result:
                    "sending: " + msg['MID'] + " to: " + msg['dst']
                    kvstore.send_put_response(msg)
                    kvstore.last_heartbeat = time.time()
                else:
                    kvstore.send_failed_response(msg)
                    
            
            
        elif msg['type'] == 'rpc':
            if msg['leader'] == msg['src']:
                #this person claims to have won an election
                if msg['leader'] != kvstore.leader:
                    #woah! something is weird here, start new election
                    kvstore.begin_election()
                    continue
                else:
                    #heartbeat from expected leader
                    kvstore.last_heartbeat = time.time()
                    
            else:
                kvstore.vote_in_election(msg['src'])
                continue
                
        
    clock = time.time()
    if clock - last > .5 and kvstore.leader == kvstore.id:
        kvstore.send_RPC()
        last = clock
        
